<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/League/AIRaceSimulator.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/League/AIRaceSimulator.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using UnityEngine;&#10;&#10;namespace League&#10;{&#10;    public static class AIRaceSimulator&#10;    {&#10;        private static System.Random random = new System.Random();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Simulates a race between AI teams and returns the finishing positions.&#10;        /// Teams with higher quality + form have better chances of winning.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;teams&quot;&gt;Teams participating in the race&lt;/param&gt;&#10;        /// &lt;returns&gt;Dictionary with team and their finishing position&lt;/returns&gt;&#10;        public static Dictionary&lt;Team, int&gt; SimulateRace(Team[] teams)&#10;        {&#10;            if (teams == null || teams.Length == 0)&#10;                return new Dictionary&lt;Team, int&gt;();&#10;&#10;            var teamPerformances = new List&lt;TeamRacePerformance&gt;();&#10;&#10;            // Calculate race performance for each team with some randomness&#10;            foreach (var team in teams)&#10;            {&#10;                float basePerformance = team.GetRacePerformance();&#10;                &#10;                // Add randomness (Â±15 points) to make races unpredictable&#10;                float randomVariation = (float)(random.NextDouble() * 30 - 15);&#10;                float finalPerformance = basePerformance + randomVariation;&#10;                &#10;                // Add small boost for teams currently in good league position (championship pressure)&#10;                float positionBonus = GetPositionBonus(team);&#10;                finalPerformance += positionBonus;&#10;&#10;                teamPerformances.Add(new TeamRacePerformance&#10;                {&#10;                    team = team,&#10;                    performance = finalPerformance&#10;                });&#10;            }&#10;&#10;            // Sort by performance (highest first = best finishing position)&#10;            teamPerformances = teamPerformances&#10;                .OrderByDescending(tp =&gt; tp.performance)&#10;                .ToList();&#10;&#10;            // Assign finishing positions and record results&#10;            var results = new Dictionary&lt;Team, int&gt;();&#10;            for (int i = 0; i &lt; teamPerformances.Count; i++)&#10;            {&#10;                int position = i + 1;&#10;                var team = teamPerformances[i].team;&#10;                &#10;                results[team] = position;&#10;                team.RecordRaceFinish(position);&#10;            }&#10;&#10;            return results;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Gives teams currently higher in standings a small performance boost&#10;        /// to help maintain competitive balance.&#10;        /// &lt;/summary&gt;&#10;        private static float GetPositionBonus(Team team)&#10;        {&#10;            var league = LeagueController.Instance?.currentLeague;&#10;            if (league?.standings == null) return 0f;&#10;&#10;            var standing = league.standings.FirstOrDefault(s =&gt; s.team == team);&#10;            if (standing.team == null) return 0f;&#10;&#10;            // Top 3 teams get small bonus, bottom teams get slight penalty&#10;            int totalTeams = league.standings.Length;&#10;            if (standing.position &lt;= 3)&#10;                return 2f; // Small boost for leaders&#10;            else if (standing.position &gt;= totalTeams - 2)&#10;                return -1f; // Small penalty for bottom teams&#10;            &#10;            return 0f; // No bonus for mid-table teams&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Simulates all non-player races for the current race week.&#10;        /// Call this when advancing the league to the next race.&#10;        /// &lt;/summary&gt;&#10;        public static void SimulateWeeklyAIRaces(League league)&#10;        {&#10;            if (league?.raceDays == null || league.currentRace &gt;= league.raceDays.Length)&#10;                return;&#10;&#10;            // Simulate ALL AI-only races for this week, not just the current race&#10;            SimulateAllAIRacesForWeek(league);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Simulates all AI-only races that should happen during the same week as the player's race.&#10;        /// This ensures AI teams that aren't racing the player still compete.&#10;        /// &lt;/summary&gt;&#10;        public static void SimulateAllAIRacesForWeek(League league)&#10;        {&#10;            if (league?.raceDays == null || league.currentRace &gt;= league.raceDays.Length)&#10;                return;&#10;&#10;            // Get all teams in the league&#10;            var allTeams = league.teams.ToList();&#10;            var playerTeam = allTeams.FirstOrDefault(t =&gt; t.teamType == TeamType.Player);&#10;            &#10;            if (playerTeam == null) return;&#10;&#10;            // Get current player race&#10;            var currentRaceDay = league.raceDays[league.currentRace];&#10;            var teamsInPlayerRace = currentRaceDay.teams?.ToList() ?? new List&lt;Team&gt;();&#10;&#10;            // Find teams NOT in the player's race&#10;            var teamsNotRacing = allTeams.Where(t =&gt; !teamsInPlayerRace.Contains(t) &amp;&amp; t != playerTeam).ToList();&#10;&#10;            // If we have enough teams not racing, create AI-only races&#10;            if (teamsNotRacing.Count &gt;= 2)&#10;            {&#10;                // Create AI-only races from remaining teams&#10;                var aiRaces = CreateAIOnlyRaces(teamsNotRacing, league.maxNumberOfBoatsPerRace);&#10;                &#10;                foreach (var aiRace in aiRaces)&#10;                {&#10;                    if (aiRace.Length &gt;= 2) // Need at least 2 teams to race&#10;                    {&#10;                        var results = SimulateRace(aiRace);&#10;                        Debug.Log($&quot;Simulated AI-only race: {string.Join(&quot;, &quot;, results.Select(r =&gt; $&quot;{r.Key.teamName}: {r.Value}&quot;))}&quot;);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Also simulate the current race if it's AI-only&#10;            var currentRaceDay2 = league.raceDays[league.currentRace];&#10;            if (currentRaceDay2.teams != null)&#10;            {&#10;                bool playerInRace = currentRaceDay2.teams.Any(t =&gt; t.teamType == TeamType.Player);&#10;&#10;                if (!playerInRace)&#10;                {&#10;                    // Simulate this AI-only race&#10;                    var results = SimulateRace(currentRaceDay2.teams);&#10;                    &#10;                    // Update the race day with results&#10;                    var positions = new int[currentRaceDay2.teams.Length];&#10;                    for (int i = 0; i &lt; currentRaceDay2.teams.Length; i++)&#10;                    {&#10;                        if (results.ContainsKey(currentRaceDay2.teams[i]))&#10;                            positions[i] = results[currentRaceDay2.teams[i]];&#10;                    }&#10;                    currentRaceDay2.positions = positions;&#10;                    league.raceDays[league.currentRace] = currentRaceDay2;&#10;                    &#10;                    Debug.Log($&quot;Simulated scheduled AI race - Results: {string.Join(&quot;, &quot;, results.Select(r =&gt; $&quot;{r.Key.teamName}: {r.Value}&quot;))}&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates AI-only races from teams that aren't racing against the player this week.&#10;        /// &lt;/summary&gt;&#10;        private static List&lt;Team[]&gt; CreateAIOnlyRaces(List&lt;Team&gt; availableTeams, int maxBoatsPerRace)&#10;        {&#10;            var aiRaces = new List&lt;Team[]&gt;();&#10;            var remainingTeams = new List&lt;Team&gt;(availableTeams);&#10;&#10;            // Create races with available teams&#10;            while (remainingTeams.Count &gt;= 2)&#10;            {&#10;                int raceSize = Mathf.Min(maxBoatsPerRace, remainingTeams.Count);&#10;&#10;                // Take teams for this race&#10;                var raceTeams = remainingTeams.Take(raceSize).ToArray();&#10;                aiRaces.Add(raceTeams);&#10;&#10;                // Remove teams from remaining pool&#10;                foreach (var team in raceTeams)&#10;                {&#10;                    remainingTeams.Remove(team);&#10;                }&#10;            }&#10;&#10;            return aiRaces;&#10;        }&#10;&#10;        private struct TeamRacePerformance&#10;        {&#10;            public Team team;&#10;            public float performance;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using UnityEngine;&#10;&#10;namespace League&#10;{&#10;    public static class AIRaceSimulator&#10;    {&#10;        private static System.Random random = new System.Random();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Simulates a race between AI teams and returns the finishing positions.&#10;        /// Teams with higher quality + form have better chances of winning.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;teams&quot;&gt;Teams participating in the race&lt;/param&gt;&#10;        /// &lt;returns&gt;Dictionary with team and their finishing position&lt;/returns&gt;&#10;        public static Dictionary&lt;Team, int&gt; SimulateRace(Team[] teams)&#10;        {&#10;            if (teams == null || teams.Length == 0)&#10;                return new Dictionary&lt;Team, int&gt;();&#10;&#10;            var teamPerformances = new List&lt;TeamRacePerformance&gt;();&#10;&#10;            // Calculate race performance for each team with some randomness&#10;            foreach (var team in teams)&#10;            {&#10;                float basePerformance = team.GetRacePerformance();&#10;                &#10;                // Add randomness (Â±15 points) to make races unpredictable&#10;                float randomVariation = (float)(random.NextDouble() * 30 - 15);&#10;                float finalPerformance = basePerformance + randomVariation;&#10;                &#10;                // Add small boost for teams currently in good league position (championship pressure)&#10;                float positionBonus = GetPositionBonus(team);&#10;                finalPerformance += positionBonus;&#10;&#10;                teamPerformances.Add(new TeamRacePerformance&#10;                {&#10;                    team = team,&#10;                    performance = finalPerformance&#10;                });&#10;            }&#10;&#10;            // Sort by performance (highest first = best finishing position)&#10;            teamPerformances = teamPerformances&#10;                .OrderByDescending(tp =&gt; tp.performance)&#10;                .ToList();&#10;&#10;            // Assign finishing positions and record results&#10;            var results = new Dictionary&lt;Team, int&gt;();&#10;            for (int i = 0; i &lt; teamPerformances.Count; i++)&#10;            {&#10;                int position = i + 1;&#10;                var team = teamPerformances[i].team;&#10;                &#10;                results[team] = position;&#10;                team.RecordRaceFinish(position);&#10;            }&#10;&#10;            return results;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Gives teams currently higher in standings a small performance boost&#10;        /// to help maintain competitive balance.&#10;        /// &lt;/summary&gt;&#10;        private static float GetPositionBonus(Team team)&#10;        {&#10;            var league = LeagueController.Instance?.currentLeague;&#10;            if (league?.standings == null) return 0f;&#10;&#10;            var standing = league.standings.FirstOrDefault(s =&gt; s.team == team);&#10;            if (standing.team == null) return 0f;&#10;&#10;            // Top 3 teams get small bonus, bottom teams get slight penalty&#10;            int totalTeams = league.standings.Length;&#10;            if (standing.position &lt;= 3)&#10;                return 2f; // Small boost for leaders&#10;            else if (standing.position &gt;= totalTeams - 2)&#10;                return -1f; // Small penalty for bottom teams&#10;            &#10;            return 0f; // No bonus for mid-table teams&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Simulates all non-player races for the current race week.&#10;        /// Call this when advancing the league to the next race.&#10;        /// &lt;/summary&gt;&#10;        public static void SimulateWeeklyAIRaces(League league)&#10;        {&#10;            if (league?.raceDays == null || league.currentRace &gt;= league.raceDays.Length)&#10;                return;&#10;&#10;            // Simulate ALL AI-only races for this week, not just the current race&#10;            SimulateAllAIRacesForWeek(league);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Simulates all AI-only races that should happen during the same week as the player's race.&#10;        /// This ensures AI teams that aren't racing the player still compete in their own heats.&#10;        /// Each team races exactly once per race button press.&#10;        /// &lt;/summary&gt;&#10;        public static void SimulateAllAIRacesForWeek(League league)&#10;        {&#10;            if (league?.raceDays == null || league.currentRace &gt;= league.raceDays.Length)&#10;                return;&#10;&#10;            // Get all teams in the league&#10;            var allTeams = league.teams.ToList();&#10;            var playerTeam = allTeams.FirstOrDefault(t =&gt; t.teamType == TeamType.Player);&#10;            &#10;            if (playerTeam == null) return;&#10;&#10;            // Get current player race&#10;            var currentRaceDay = league.raceDays[league.currentRace];&#10;            var teamsInPlayerRace = currentRaceDay.teams?.ToList() ?? new List&lt;Team&gt;();&#10;&#10;            // Find teams NOT in the player's race - these need to race in their own heats&#10;            var teamsNotRacing = allTeams.Where(t =&gt; !teamsInPlayerRace.Contains(t) &amp;&amp; t != playerTeam).ToList();&#10;&#10;            // Create exactly ONE heat for the remaining teams&#10;            if (teamsNotRacing.Count &gt;= 2)&#10;            {&#10;                // Create a single AI-only race with all remaining teams (up to max boats per race)&#10;                int raceSize = Mathf.Min(league.maxNumberOfBoatsPerRace, teamsNotRacing.Count);&#10;                var raceTeams = teamsNotRacing.Take(raceSize).ToArray();&#10;                &#10;                if (raceTeams.Length &gt;= 2) // Need at least 2 teams to race&#10;                {&#10;                    var results = SimulateRace(raceTeams);&#10;                    Debug.Log($&quot;Simulated AI heat: {string.Join(&quot;, &quot;, results.Select(r =&gt; $&quot;{r.Key.teamName}: {r.Value}&quot;))}&quot;);&#10;                    &#10;                    // Log points awarded to verify max 25 points&#10;                    foreach (var result in results)&#10;                    {&#10;                        int points = CalculatePointsForPosition(result.Value, raceTeams.Length);&#10;                        Debug.Log($&quot;{result.Key.teamName} earned {points} points for position {result.Value}&quot;);&#10;                    }&#10;                }&#10;&#10;                // If there are still teams left over (more than max boats per race), they don't race this week&#10;                if (teamsNotRacing.Count &gt; league.maxNumberOfBoatsPerRace)&#10;                {&#10;                    var leftOverTeams = teamsNotRacing.Skip(raceSize).ToList();&#10;                    Debug.Log($&quot;Teams sitting out this week: {string.Join(&quot;, &quot;, leftOverTeams.Select(t =&gt; t.teamName))}&quot;);&#10;                }&#10;            }&#10;&#10;            // Handle scheduled AI-only races (if any exist in the race days)&#10;            var currentRaceDay2 = league.raceDays[league.currentRace];&#10;            if (currentRaceDay2.teams != null)&#10;            {&#10;                bool playerInRace = currentRaceDay2.teams.Any(t =&gt; t.teamType == TeamType.Player);&#10;&#10;                if (!playerInRace)&#10;                {&#10;                    // This is a scheduled AI-only race - simulate it&#10;                    var results = SimulateRace(currentRaceDay2.teams);&#10;                    &#10;                    // Update the race day with results&#10;                    var positions = new int[currentRaceDay2.teams.Length];&#10;                    for (int i = 0; i &lt; currentRaceDay2.teams.Length; i++)&#10;                    {&#10;                        if (results.ContainsKey(currentRaceDay2.teams[i]))&#10;                            positions[i] = results[currentRaceDay2.teams[i]];&#10;                    }&#10;                    currentRaceDay2.positions = positions;&#10;                    league.raceDays[league.currentRace] = currentRaceDay2;&#10;                    &#10;                    Debug.Log($&quot;Simulated scheduled AI race - Results: {string.Join(&quot;, &quot;, results.Select(r =&gt; $&quot;{r.Key.teamName}: {r.Value}&quot;))}&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Calculates points for a finishing position (F1-style scoring).&#10;        /// 1st = 25, 2nd = 18, 3rd = 15, 4th = 12, etc.&#10;        /// &lt;/summary&gt;&#10;        private static int CalculatePointsForPosition(int position, int totalRacers)&#10;        {&#10;            return position switch&#10;            {&#10;                1 =&gt; 25,&#10;                2 =&gt; 18,&#10;                3 =&gt; 15,&#10;                4 =&gt; 12,&#10;                5 =&gt; 10,&#10;                6 =&gt; 8,&#10;                7 =&gt; 6,&#10;                8 =&gt; 4,&#10;                9 =&gt; 2,&#10;                10 =&gt; 1,&#10;                _ =&gt; 0&#10;            };&#10;        }&#10;&#10;        private struct TeamRacePerformance&#10;        {&#10;            public Team team;&#10;            public float performance;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/League/Editor/LeagueControllerEditor.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/League/Editor/LeagueControllerEditor.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEditor;&#10;using League;&#10;&#10;[CustomEditor(typeof(LeagueController))]&#10;public class LeagueControllerEditor : Editor&#10;{&#10;    public override void OnInspectorGUI()&#10;    {&#10;        // Draw the default inspector&#10;        DrawDefaultInspector();&#10;        &#10;        GUILayout.Space(10);&#10;        &#10;        LeagueController leagueController = (LeagueController)target;&#10;        &#10;        // Add a visible button to clear the league&#10;        if (GUILayout.Button(&quot;Clear League&quot;, GUILayout.Height(30)))&#10;        {&#10;            if (EditorUtility.DisplayDialog(&quot;Clear League&quot;, &#10;                &quot;Are you sure you want to clear the current league? This will reset all race data and team stats.&quot;, &#10;                &quot;Yes&quot;, &quot;Cancel&quot;))&#10;            {&#10;                leagueController.ClearLeague();&#10;            }&#10;        }&#10;        &#10;        GUILayout.Space(5);&#10;        &#10;        // Add some helpful info&#10;        if (leagueController.currentLeague != null)&#10;        {&#10;            EditorGUILayout.HelpBox($&quot;Current League: {leagueController.currentLeague.leagueName}\n&quot; +&#10;                                  $&quot;Current Race: {leagueController.currentLeague.currentRace + 1}\n&quot; +&#10;                                  $&quot;Total Races: {leagueController.currentLeague.raceDays?.Length ?? 0}\n&quot; +&#10;                                  $&quot;Season Finished: {leagueController.currentLeague.isFinished}&quot;, &#10;                                  MessageType.Info);&#10;        }&#10;        else&#10;        {&#10;            EditorGUILayout.HelpBox(&quot;No current league assigned!&quot;, MessageType.Warning);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/League/LeagueController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/League/LeagueController.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;using System.Linq;&#10;&#10;namespace League&#10;{&#10;    public class LeagueController : MonoBehaviour&#10;    {&#10;        public static LeagueController Instance { get; private set; }&#10;        public League currentLeague;&#10;        public League[] leagues;&#10;        &#10;        &#10;        private void Awake()&#10;        {&#10;            if (Instance == null)&#10;            {&#10;                Instance = this;&#10;                DontDestroyOnLoad(gameObject);&#10;            }&#10;            else&#10;            {&#10;                Destroy(gameObject);&#10;            }&#10;        }&#10;&#10;&#10;        private void Start()&#10;        {&#10;            // Generate raw schedule and enforce repeat and limit&#10;            var rawSchedule = currentLeague.GenerateRaceSchedule(currentLeague.teams, currentLeague.maxNumberOfBoatsPerRace, currentLeague.repeatCount).ToList();&#10;            if (rawSchedule.Count &gt; currentLeague.maxRaces)&#10;                rawSchedule = rawSchedule.Take(currentLeague.maxRaces).ToList();&#10;            // Initialize race days array&#10;            currentLeague.raceDays = new RaceDayFormation[rawSchedule.Count];&#10;            for (int i = 0; i &lt; rawSchedule.Count; i++)&#10;            {&#10;                currentLeague.raceDays[i] = new RaceDayFormation&#10;                {&#10;                    teams = rawSchedule[i],&#10;                    positions = new int[rawSchedule[i].Length]&#10;                };&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Advances to the next race in the league schedule.&#10;        /// Automatically simulates AI-only races.&#10;        /// &lt;/summary&gt;&#10;        public void AdvanceToNextRace()&#10;        {&#10;            if (currentLeague == null || currentLeague.raceDays == null) return;&#10;            &#10;            // Simulate current race if it's AI-only&#10;            AIRaceSimulator.SimulateWeeklyAIRaces(currentLeague);&#10;            &#10;            // Move to next race&#10;            currentLeague.currentRace++;&#10;            &#10;            // Check if season is complete&#10;            if (currentLeague.currentRace &gt;= currentLeague.raceDays.Length)&#10;            {&#10;                CompleteSeasonInternal();&#10;                return;&#10;            }&#10;            &#10;            // Update standings after race results&#10;            currentLeague.RecalculateStandings();&#10;            &#10;            // Simulate next race if it's also AI-only (for multiple AI races per week)&#10;            AIRaceSimulator.SimulateWeeklyAIRaces(currentLeague);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Gets the current race that the player should participate in.&#10;        /// Returns null if no player races remaining.&#10;        /// &lt;/summary&gt;&#10;        public RaceDayFormation? GetCurrentPlayerRace()&#10;        {&#10;            if (currentLeague?.raceDays == null) return null;&#10;            &#10;            // Look for next race containing the player&#10;            for (int i = currentLeague.currentRace; i &lt; currentLeague.raceDays.Length; i++)&#10;            {&#10;                var raceDay = currentLeague.raceDays[i];&#10;                if (raceDay.teams?.Any(t =&gt; t.teamType == TeamType.Player) == true)&#10;                {&#10;                    return raceDay;&#10;                }&#10;            }&#10;            &#10;            return null;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Records the player's race result and advances the league.&#10;        /// &lt;/summary&gt;&#10;        public void RecordPlayerRaceResult(int playerPosition, Team[] raceTeams, int[] allPositions)&#10;        {&#10;            if (currentLeague?.raceDays == null) return;&#10;            &#10;            // Find and update the current race day&#10;            var currentRaceDay = currentLeague.raceDays[currentLeague.currentRace];&#10;            currentRaceDay.positions = allPositions;&#10;            currentLeague.raceDays[currentLeague.currentRace] = currentRaceDay;&#10;            &#10;            // Record results for all teams in this race&#10;            for (int i = 0; i &lt; raceTeams.Length &amp;&amp; i &lt; allPositions.Length; i++)&#10;            {&#10;                raceTeams[i].RecordRaceFinish(allPositions[i]);&#10;            }&#10;            &#10;            // Advance to next race&#10;            AdvanceToNextRace();&#10;        }&#10;&#10;        private void CompleteSeasonInternal()&#10;        {&#10;            currentLeague.isFinished = true;&#10;            currentLeague.RecalculateStandings();&#10;            Debug.Log($&quot;Season {currentLeague.currentSeason} completed for {currentLeague.leagueName}!&quot;);&#10;            &#10;            // TODO: Handle promotion/relegation, start new season, etc.&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Clears the current league and resets all race data.&#10;        /// This method can be called from the inspector button.&#10;        /// &lt;/summary&gt;&#10;        [ContextMenu(&quot;Clear League&quot;)]&#10;        public void ClearLeague()&#10;        {&#10;            if (currentLeague != null)&#10;            {&#10;                currentLeague.currentRace = 0;&#10;                currentLeague.isFinished = false;&#10;                currentLeague.raceDays = null;&#10;                currentLeague.standings = null;&#10;                &#10;                // Reset all team stats&#10;                if (currentLeague.teams != null)&#10;                {&#10;                    foreach (var team in currentLeague.teams)&#10;                    {&#10;                        if (team != null)&#10;                        {&#10;                            team.ResetCurrentSeasonStats();&#10;                        }&#10;                    }&#10;                }&#10;                &#10;                Debug.Log($&quot;League '{currentLeague.leagueName}' has been cleared and reset!&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;No current league to clear!&quot;);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Regenerates the race schedule for the current league.&#10;        /// Useful for testing different race combinations.&#10;        /// &lt;/summary&gt;&#10;        [ContextMenu(&quot;Regenerate Race Schedule&quot;)]&#10;        public void RegenerateRaceSchedule()&#10;        {&#10;            if (currentLeague != null)&#10;            {&#10;                Start(); // Calls the race generation logic&#10;                Debug.Log($&quot;Race schedule regenerated for '{currentLeague.leagueName}'!&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;No current league to regenerate schedule for!&quot;);&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;using System.Linq;&#10;&#10;namespace League&#10;{&#10;    public class LeagueController : MonoBehaviour&#10;    {&#10;        public static LeagueController Instance { get; private set; }&#10;        public League currentLeague;&#10;        public League[] leagues;&#10;        &#10;        &#10;        private void Awake()&#10;        {&#10;            if (Instance == null)&#10;            {&#10;                Instance = this;&#10;                DontDestroyOnLoad(gameObject);&#10;            }&#10;            else&#10;            {&#10;                Destroy(gameObject);&#10;            }&#10;        }&#10;&#10;&#10;        private void Start()&#10;        {&#10;            // Generate raw schedule and enforce repeat and limit&#10;            var rawSchedule = currentLeague.GenerateRaceSchedule(currentLeague.teams, currentLeague.maxNumberOfBoatsPerRace, currentLeague.repeatCount).ToList();&#10;            if (rawSchedule.Count &gt; currentLeague.maxRaces)&#10;                rawSchedule = rawSchedule.Take(currentLeague.maxRaces).ToList();&#10;            // Initialize race days array&#10;            currentLeague.raceDays = new RaceDayFormation[rawSchedule.Count];&#10;            for (int i = 0; i &lt; rawSchedule.Count; i++)&#10;            {&#10;                currentLeague.raceDays[i] = new RaceDayFormation&#10;                {&#10;                    teams = rawSchedule[i],&#10;                    positions = new int[rawSchedule[i].Length]&#10;                };&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Advances to the next race in the league schedule.&#10;        /// Automatically simulates AI-only races.&#10;        /// &lt;/summary&gt;&#10;        public void AdvanceToNextRace()&#10;        {&#10;            if (currentLeague == null || currentLeague.raceDays == null) return;&#10;            &#10;            // Simulate current race if it's AI-only&#10;            AIRaceSimulator.SimulateWeeklyAIRaces(currentLeague);&#10;            &#10;            // Move to next race&#10;            currentLeague.currentRace++;&#10;            &#10;            // Check if season is complete&#10;            if (currentLeague.currentRace &gt;= currentLeague.raceDays.Length)&#10;            {&#10;                CompleteSeasonInternal();&#10;                return;&#10;            }&#10;            &#10;            // Update standings after race results&#10;            currentLeague.RecalculateStandings();&#10;            &#10;            // Simulate next race if it's also AI-only (for multiple AI races per week)&#10;            AIRaceSimulator.SimulateWeeklyAIRaces(currentLeague);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Gets the current race that the player should participate in.&#10;        /// Returns null if no player races remaining.&#10;        /// &lt;/summary&gt;&#10;        public RaceDayFormation? GetCurrentPlayerRace()&#10;        {&#10;            if (currentLeague?.raceDays == null) return null;&#10;            &#10;            // Look for next race containing the player&#10;            for (int i = currentLeague.currentRace; i &lt; currentLeague.raceDays.Length; i++)&#10;            {&#10;                var raceDay = currentLeague.raceDays[i];&#10;                if (raceDay.teams?.Any(t =&gt; t.teamType == TeamType.Player) == true)&#10;                {&#10;                    return raceDay;&#10;                }&#10;            }&#10;            &#10;            return null;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Records the player's race result and advances the league.&#10;        /// &lt;/summary&gt;&#10;        public void RecordPlayerRaceResult(int playerPosition, Team[] raceTeams, int[] allPositions)&#10;        {&#10;            if (currentLeague?.raceDays == null) return;&#10;            &#10;            // Find and update the current race day&#10;            var currentRaceDay = currentLeague.raceDays[currentLeague.currentRace];&#10;            currentRaceDay.positions = allPositions;&#10;            currentLeague.raceDays[currentLeague.currentRace] = currentRaceDay;&#10;            &#10;            // Record results for all teams in this race&#10;            for (int i = 0; i &lt; raceTeams.Length &amp;&amp; i &lt; allPositions.Length; i++)&#10;            {&#10;                raceTeams[i].RecordRaceFinish(allPositions[i]);&#10;            }&#10;            &#10;            // Advance to next race&#10;            AdvanceToNextRace();&#10;        }&#10;&#10;        private void CompleteSeasonInternal()&#10;        {&#10;            currentLeague.isFinished = true;&#10;            currentLeague.RecalculateStandings();&#10;            Debug.Log($&quot;Season {currentLeague.currentSeason} completed for {currentLeague.leagueName}!&quot;);&#10;            &#10;            // TODO: Handle promotion/relegation, start new season, etc.&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Clears the current league and resets all race data.&#10;        /// This method can be called from the inspector button.&#10;        /// &lt;/summary&gt;&#10;        [ContextMenu(&quot;Clear League&quot;)]&#10;        public void ClearLeague()&#10;        {&#10;            if (currentLeague != null)&#10;            {&#10;                currentLeague.currentRace = 0;&#10;                currentLeague.isFinished = false;&#10;                currentLeague.raceDays = null;&#10;                currentLeague.standings = null;&#10;                &#10;                // Reset all team stats&#10;                if (currentLeague.teams != null)&#10;                {&#10;                    foreach (var team in currentLeague.teams)&#10;                    {&#10;                        if (team != null)&#10;                        {&#10;                            team.ResetCurrentSeasonStats();&#10;                        }&#10;                    }&#10;                }&#10;                &#10;                Debug.Log($&quot;League '{currentLeague.leagueName}' has been cleared and reset!&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;No current league to clear!&quot;);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Regenerates the race schedule for the current league.&#10;        /// Useful for testing different race combinations.&#10;        /// &lt;/summary&gt;&#10;        [ContextMenu(&quot;Regenerate Race Schedule&quot;)]&#10;        public void RegenerateRaceSchedule()&#10;        {&#10;            if (currentLeague != null)&#10;            {&#10;                Start(); // Calls the race generation logic&#10;                Debug.Log($&quot;Race schedule regenerated for '{currentLeague.leagueName}'!&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;No current league to regenerate schedule for!&quot;);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/League/ListExtensions.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/League/ListExtensions.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;&#10;namespace League&#10;{&#10;    public static class ListExtensions&#10;    {&#10;        private static Random rng = new Random();&#10;&#10;        public static void Shuffle&lt;T&gt;(this IList&lt;T&gt; list)&#10;        {&#10;            int n = list.Count;&#10;            while (n &gt; 1)&#10;            {&#10;                n--;&#10;                int k = rng.Next(n + 1);&#10;                T value = list[k];&#10;                list[k] = list[n];&#10;                list[n] = value;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/League/Team.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/League/Team.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using UnityEngine;&#10;&#10;[CreateAssetMenu(fileName = &quot;NewTeam&quot;, menuName = &quot;League/Team&quot;)]&#10;public class Team : ScriptableObject&#10;{&#10;    [Header(&quot;Team Details&quot;)]&#10;    public string teamName;&#10;    public string teamDescription;&#10;    public Sprite teamLogo;&#10;    public Color teamColor;&#10;    public int teamQuality;&#10;    public TeamType teamType = TeamType.AI; // Type of team (Player, AI, Custom)&#10;&#10;    [Header(&quot;Form &amp; Performance&quot;)]&#10;    [Tooltip(&quot;Current form rating (0-100). Higher form = better recent performance.&quot;)]&#10;    [Range(0, 100)]&#10;    public float currentForm = 50f;&#10;    [Tooltip(&quot;Recent race results used to calculate form (last 5 races).&quot;)]&#10;    public List&lt;int&gt; recentResults = new List&lt;int&gt;();&#10;&#10;    [Header(&quot;Team Members&quot;)]&#10;    public TeamMember[] teamMembers;&#10;&#10;    [Header(&quot;Current Season Stats&quot;)]&#10;    [Tooltip(&quot;Wins, draws, losses, and points for the current season.&quot;)]&#10;    public SeasonStats currentSeasonStats;&#10;&#10;    [Header(&quot;All-Time Stats&quot;)]&#10;    [Tooltip(&quot;Cumulative wins, draws, losses, and points across all seasons.&quot;)]&#10;    public SeasonStats lifetimeStats;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Records a race finish position, updating both season and lifetime stats.&#10;    /// &lt;/summary&gt;&#10;    public void RecordRaceFinish(int position)&#10;    {&#10;        currentSeasonStats.finishes.Add(position);&#10;        lifetimeStats.finishes.Add(position);&#10;        UpdateForm(position);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates team form based on recent race results.&#10;    /// &lt;/summary&gt;&#10;    private void UpdateForm(int position)&#10;    {&#10;        recentResults.Add(position);&#10;        &#10;        // Keep only last 5 results for form calculation&#10;        if (recentResults.Count &gt; 5)&#10;            recentResults.RemoveAt(0);&#10;        &#10;        // Calculate form based on recent results (1st = 100 points, 2nd = 90, etc.)&#10;        float formTotal = 0f;&#10;        foreach (int result in recentResults)&#10;        {&#10;            // Convert position to form points (1st = 100, 2nd = 90, 3rd = 80, etc.)&#10;            float formPoints = Mathf.Max(0, 110 - (result * 10));&#10;            formTotal += formPoints;&#10;        }&#10;        &#10;        currentForm = formTotal / recentResults.Count;&#10;        currentForm = Mathf.Clamp(currentForm, 0f, 100f);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the effective race performance combining quality and form.&#10;    /// &lt;/summary&gt;&#10;    public float GetRacePerformance()&#10;    {&#10;        // Combine base quality (60%) with current form (40%)&#10;        return (teamQuality * 0.6f) + (currentForm * 0.4f);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Resets only the current season stats (e.g. at season start).&#10;    /// &lt;/summary&gt;&#10;    public void ResetCurrentSeasonStats()&#10;    {&#10;        currentSeasonStats = new SeasonStats();&#10;        // Reset form to base level at season start&#10;        currentForm = 50f;&#10;        recentResults.Clear();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the team's combined stats from all team members.&#10;    /// Returns average stats if team has members, otherwise generates stats based on team quality.&#10;    /// &lt;/summary&gt;&#10;    public CharacterStats GetTeamStats()&#10;    {&#10;        if (teamMembers != null &amp;&amp; teamMembers.Length &gt; 0)&#10;        {&#10;            // Calculate average stats from all team members&#10;            float totalStrength = 0f;&#10;            float totalStamina = 0f;&#10;            float totalTechnique = 0f;&#10;            float totalTeamWork = 0f;&#10;            int memberCount = 0;&#10;&#10;            foreach (var member in teamMembers)&#10;            {&#10;                if (member != null)&#10;                {&#10;                    var memberStats = member.GetStats();&#10;                    totalStrength += memberStats.strength;&#10;                    totalStamina += memberStats.stamina;&#10;                    totalTechnique += memberStats.technique;&#10;                    totalTeamWork += memberStats.teamWork;&#10;                    memberCount++;&#10;                }&#10;            }&#10;&#10;            if (memberCount &gt; 0)&#10;            {&#10;                return new CharacterStats(&#10;                    strength: totalStrength / memberCount,&#10;                    stamina: totalStamina / memberCount,&#10;                    technique: totalTechnique / memberCount,&#10;                    teamWork: totalTeamWork / memberCount&#10;                );&#10;            }&#10;        }&#10;&#10;        // Fallback: Generate stats based on team quality and form&#10;        float baseValue = teamQuality / 10f; // Convert 0-100 to 0-10 range&#10;        float formModifier = (currentForm - 50f) / 50f; // -1 to +1 range&#10;        float variation = 0.2f; // 20% variation between stats&#10;&#10;        return new CharacterStats(&#10;            strength: baseValue + (formModifier * 1f) + UnityEngine.Random.Range(-variation, variation),&#10;            stamina: baseValue + (formModifier * 1f) + UnityEngine.Random.Range(-variation, variation),&#10;            technique: baseValue + (formModifier * 0.8f) + UnityEngine.Random.Range(-variation, variation),&#10;            teamWork: baseValue + (formModifier * 0.8f) + UnityEngine.Random.Range(-variation, variation)&#10;        );&#10;    }&#10;}&#10;&#10;public enum TeamType&#10;{&#10;    None,&#10;    Player,&#10;    AI,&#10;    Custom&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using UnityEngine;&#10;&#10;[CreateAssetMenu(fileName = &quot;NewTeam&quot;, menuName = &quot;League/Team&quot;)]&#10;public class Team : ScriptableObject&#10;{&#10;    [Header(&quot;Team Details&quot;)]&#10;    public string teamName;&#10;    public string teamDescription;&#10;    public Sprite teamLogo;&#10;    public Color teamColor;&#10;    public int teamQuality;&#10;    public TeamType teamType = TeamType.AI; // Type of team (Player, AI, Custom)&#10;&#10;    [Header(&quot;Form &amp; Performance&quot;)]&#10;    [Tooltip(&quot;Current form rating (0-100). Higher form = better recent performance.&quot;)]&#10;    [Range(0, 100)]&#10;    public float currentForm = 50f;&#10;    [Tooltip(&quot;Recent race results used to calculate form (last 5 races).&quot;)]&#10;    public List&lt;int&gt; recentResults = new List&lt;int&gt;();&#10;&#10;    [Header(&quot;Team Members&quot;)]&#10;    public TeamMember[] teamMembers;&#10;&#10;    [Header(&quot;Current Season Stats&quot;)]&#10;    [Tooltip(&quot;Wins, draws, losses, and points for the current season.&quot;)]&#10;    public SeasonStats currentSeasonStats;&#10;&#10;    [Header(&quot;All-Time Stats&quot;)]&#10;    [Tooltip(&quot;Cumulative wins, draws, losses, and points across all seasons.&quot;)]&#10;    public SeasonStats lifetimeStats;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Records a race finish position, updating both season and lifetime stats.&#10;    /// &lt;/summary&gt;&#10;    public void RecordRaceFinish(int position)&#10;    {&#10;        currentSeasonStats.finishes.Add(position);&#10;        lifetimeStats.finishes.Add(position);&#10;        UpdateForm(position);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates team form based on recent race results.&#10;    /// &lt;/summary&gt;&#10;    private void UpdateForm(int position)&#10;    {&#10;        recentResults.Add(position);&#10;        &#10;        // Keep only last 5 results for form calculation&#10;        if (recentResults.Count &gt; 5)&#10;            recentResults.RemoveAt(0);&#10;        &#10;        // Calculate form based on recent results (1st = 100 points, 2nd = 90, etc.)&#10;        float formTotal = 0f;&#10;        foreach (int result in recentResults)&#10;        {&#10;            // Convert position to form points (1st = 100, 2nd = 90, 3rd = 80, etc.)&#10;            float formPoints = Mathf.Max(0, 110 - (result * 10));&#10;            formTotal += formPoints;&#10;        }&#10;        &#10;        currentForm = formTotal / recentResults.Count;&#10;        currentForm = Mathf.Clamp(currentForm, 0f, 100f);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the effective race performance combining quality and form.&#10;    /// &lt;/summary&gt;&#10;    public float GetRacePerformance()&#10;    {&#10;        // Combine base quality (60%) with current form (40%)&#10;        return (teamQuality * 0.6f) + (currentForm * 0.4f);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Resets only the current season stats (e.g. at season start).&#10;    /// &lt;/summary&gt;&#10;    public void ResetCurrentSeasonStats()&#10;    {&#10;        currentSeasonStats = new SeasonStats();&#10;        // Reset form to base level at season start&#10;        currentForm = 50f;&#10;        recentResults.Clear();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the team's combined stats from all team members.&#10;    /// Returns average stats if team has members, otherwise generates stats based on team quality.&#10;    /// &lt;/summary&gt;&#10;    public CharacterStats GetTeamStats()&#10;    {&#10;        if (teamMembers != null &amp;&amp; teamMembers.Length &gt; 0)&#10;        {&#10;            // Calculate average stats from all team members&#10;            float totalStrength = 0f;&#10;            float totalStamina = 0f;&#10;            float totalTechnique = 0f;&#10;            float totalTeamWork = 0f;&#10;            int memberCount = 0;&#10;&#10;            foreach (var member in teamMembers)&#10;            {&#10;                if (member != null)&#10;                {&#10;                    var memberStats = member.GetStats();&#10;                    totalStrength += memberStats.strength;&#10;                    totalStamina += memberStats.stamina;&#10;                    totalTechnique += memberStats.technique;&#10;                    totalTeamWork += memberStats.teamWork;&#10;                    memberCount++;&#10;                }&#10;            }&#10;&#10;            if (memberCount &gt; 0)&#10;            {&#10;                return new CharacterStats(&#10;                    strength: totalStrength / memberCount,&#10;                    stamina: totalStamina / memberCount,&#10;                    technique: totalTechnique / memberCount,&#10;                    teamWork: totalTeamWork / memberCount&#10;                );&#10;            }&#10;        }&#10;&#10;        // Fallback: Generate stats based on team quality and form&#10;        float baseValue = teamQuality / 10f; // Convert 0-100 to 0-10 range&#10;        float formModifier = (currentForm - 50f) / 50f; // -1 to +1 range&#10;        float variation = 0.2f; // 20% variation between stats&#10;&#10;        return new CharacterStats(&#10;            strength: baseValue + (formModifier * 1f) + UnityEngine.Random.Range(-variation, variation),&#10;            stamina: baseValue + (formModifier * 1f) + UnityEngine.Random.Range(-variation, variation),&#10;            technique: baseValue + (formModifier * 0.8f) + UnityEngine.Random.Range(-variation, variation),&#10;            teamWork: baseValue + (formModifier * 0.8f) + UnityEngine.Random.Range(-variation, variation)&#10;        );&#10;    }&#10;}&#10;&#10;public enum TeamType&#10;{&#10;    None,&#10;    Player,&#10;    AI,&#10;    Custom&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/RaceManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/RaceManager.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System.ComponentModel.Design.Serialization;&#10;using System.Threading;&#10;using Calendar;&#10;using UnityEngine;&#10;using UnityEngine.Events;&#10;using UnityEngine.Rendering.Universal;&#10;using EventType = UnityEngine.EventType;&#10;using Random = UnityEngine.Random;&#10;using League;&#10;&#10;public class RaceManager : MonoBehaviour&#10;{&#10;    public static RaceManager Instance { get; private set; }&#10;    public Camera mainCamera;&#10;    public bool isRaceStarted = false;&#10;    [Header(&quot;Spawn &amp; Difficulty&quot;)]&#10;    [Range(0.5f, 100f)]&#10;    public float difficulty = 1f; &#10;    // 0.5 = easy crews, 1 = normal, 2 = monster crews&#10;    public List&lt;Transform&gt; raceStartPositions;&#10;    public UnityEvent startRace;&#10;    public bool isRaceDay;&#10;&#10;&#10;    public GameObject shipPrefab;&#10;    &#10;    &#10;    public List&lt;GameObject&gt; ships = new List&lt;GameObject&gt;();&#10;&#10;    public List&lt;ShipMovement&gt; RaceMovementPositions;&#10;    &#10;    public ShipMovement playerShip;&#10;    &#10;    [SerializeField]&#10;    private FinishMenu finishMenu;&#10;    &#10;    &#10;    [SerializeField]&#10;    public bool waitingForAd = false; // Flag to check if we are waiting for an ad to show&#10;&#10;    public FMOD.Studio.EventInstance GarageAmbience;&#10;    FMOD.Studio.EventInstance RaceAmbience;&#10;    public FMOD.Studio.EventInstance CheeringAndClapping;&#10;    FMOD.Studio.EventInstance NegativeEncouragement;&#10;&#10;    private void Awake()&#10;    {&#10;        if (Instance == null)&#10;        {&#10;            Instance = this;&#10;&#10;            GarageAmbience = FMODUnity.RuntimeManager.CreateInstance(&quot;event:/Garage/Garage Ambience&quot;);&#10;            GarageAmbience.start();&#10;        }&#10;        else&#10;        {&#10;            Destroy(gameObject);&#10;        }&#10;    }&#10;&#10;&#10;    public void OnEnable()&#10;    {&#10;        TimeManager.Instance.todaysEvents.AddListener(CheckForRaceDay);&#10;    }&#10;&#10;    &#10;    // Listener receives today's events list&#10;    public void CheckForRaceDay(List&lt;DayEventType&gt; todaysEvents)&#10;    {&#10;&#10;        if (todaysEvents != null &amp;&amp; todaysEvents.Count &gt; 0)&#10;        {&#10;            todaysEvents.ForEach(eventType =&gt;&#10;            {&#10;                if (eventType.OccasionType == Calendar.OccasionType.Race)&#10;                {&#10;                    isRaceDay = true;&#10;                }&#10;                else&#10;                {&#10;                   isRaceDay = false;&#10;                }&#10;                &#10;            });&#10;        }&#10;    }&#10;&#10;    public void SpawnShips()&#10;    {&#10;        if (!GameManager.Instance.GetGameStarted()) return;&#10;        &#10;        // Get the teams scheduled for this race from the league&#10;        var currentRace = LeagueController.Instance?.GetCurrentPlayerRace();&#10;        if (!currentRace.HasValue)&#10;        {&#10;            Debug.LogWarning(&quot;No current race found in league - using fallback ship spawning&quot;);&#10;            SpawnShipsWithFallback();&#10;            return;&#10;        }&#10;&#10;        var raceTeams = currentRace.Value.teams;&#10;        &#10;        // Ensure we don't spawn more ships than we have start positions&#10;        int shipsToSpawn = Mathf.Min(raceTeams.Length, raceStartPositions.Count);&#10;        &#10;        for (int i = 0; i &lt; shipsToSpawn; i++)&#10;        {&#10;            Transform racepos = raceStartPositions[i];&#10;            Team team = raceTeams[i];&#10;            &#10;            Debug.Log($&quot;Spawning ship for team: {team.teamName} at position: {racepos.position}&quot;);&#10;            &#10;            GameObject ship = Instantiate(shipPrefab, racepos.position, shipPrefab.transform.rotation);&#10;            var movement = ship.GetComponent&lt;ShipMovement&gt;();&#10;            &#10;            // Assign team data to ship&#10;            movement.shipName = team.teamName;&#10;            ship.name = team.teamName + &quot;_Ship&quot;;&#10;            &#10;            if (team.teamType == TeamType.Player)&#10;            {&#10;                // Set up player ship&#10;                movement.stats = PlayerManager.Instance.GetPlayerStats();&#10;                movement.isPlayerShip = true;&#10;                movement.shipName = &quot;Player Ship&quot;;&#10;                ship.name = &quot;PlayerShip&quot;;&#10;                playerShip = movement;&#10;            }&#10;            else&#10;            {&#10;                // Set up AI ship with team stats&#10;                movement.stats = team.GetTeamStats();&#10;                movement.isPlayerShip = false;&#10;            }&#10;            &#10;            ships.Add(ship);&#10;        }&#10;        &#10;        StartCoroutine(StartShips());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Fallback method for spawning ships when no league race is available&#10;    /// &lt;/summary&gt;&#10;    private void SpawnShipsWithFallback()&#10;    {&#10;        foreach (Transform racepos in raceStartPositions)&#10;        {&#10;            Debug.Log(&quot;Spawning ship at position: &quot; + racepos.position);&#10;            GameObject ship = Instantiate(shipPrefab, racepos.position, shipPrefab.transform.rotation);&#10;            var movement = ship.GetComponent&lt;ShipMovement&gt;();&#10;            movement.shipName = &quot;Ship &quot; + (ships.Count + 1);&#10;            &#10;            // Generate AI stats as fallback&#10;            var aiStats = new CharacterStats(&#10;                strength : Random.Range(8f, 12f)  * difficulty,&#10;                stamina  : Random.Range(8f, 12f)  * difficulty,&#10;                technique: Random.Range(5f, 10f)  * difficulty,&#10;                teamWork : Random.Range(5f, 10f)  * difficulty&#10;            );&#10;            movement.stats = aiStats;&#10;            &#10;            ships.Add(ship);&#10;        }&#10;        &#10;        // Mark one as &quot;player&quot; for fallback&#10;        var playerGO = ships[ships.Count - 1];&#10;        var playerMove = playerGO.GetComponent&lt;ShipMovement&gt;();&#10;        playerMove.stats = PlayerManager.Instance.GetPlayerStats();&#10;        playerMove.isPlayerShip = true;&#10;        playerMove.shipName = &quot;Player Ship&quot;;&#10;        playerGO.name = &quot;PlayerShip&quot;;&#10;        playerShip = playerMove;&#10;        &#10;        StartCoroutine(StartShips());&#10;    }&#10;&#10;    IEnumerator StartShips()&#10;    {&#10;        yield return new WaitForSeconds(1f);&#10;        startRace.Invoke();&#10;&#10;        RaceAmbience = FMODUnity.RuntimeManager.CreateInstance(&quot;event:/Race/Race Ambience&quot;);&#10;        RaceAmbience.start();&#10;        GarageAmbience.setParameterByName(&quot;Mute Garage Ambience&quot;, 0f);&#10;        //GarageAmbience.stop(FMOD.Studio.STOP_MODE.ALLOWFADEOUT);&#10;&#10;        foreach (var go in ships)&#10;            go.GetComponent&lt;ShipMovement&gt;().SetRaceStarted(true);&#10;    }&#10;&#10;    public void ShipFinished(ShipMovement ship)&#10;    {&#10;        RaceMovementPositions.Add(ship);&#10;        &#10;        bool raceisFinished = RaceFinished();&#10;&#10;        if (ship.isPlayerShip)&#10;        {&#10;            foreach(GameObject shipGO in ships)&#10;            {&#10;                ShipMovement shipMovement = shipGO.GetComponent&lt;ShipMovement&gt;();&#10;                if(shipMovement!=null)&#10;                {&#10;                   shipMovement.SetAiStatsAfterPlayerFinished(10f); // Speed up AI ships after player finishes&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (raceisFinished)&#10;        {&#10;            foreach (ShipMovement shipMovement in RaceMovementPositions)&#10;            {&#10;                Debug.Log(&quot;Ship finished: &quot; + shipMovement.shipName + &quot; at position: &quot; + (RaceMovementPositions.IndexOf(shipMovement) + 1));&#10;            }&#10;            &#10;            if(GameManager.Instance.CanShowAd())&#10;            {&#10;                StartCoroutine(ShowAd());&#10;                GameManager.Instance.HideBannerAd();&#10;            }&#10;            &#10;            &#10;        }&#10;        &#10;     &#10;    }&#10;    &#10;    public void IsRaceFinished()&#10;    {&#10;        if (RaceFinished())&#10;        {&#10;            if(finishMenu == null)&#10;            {&#10;                finishMenu = FindObjectOfType&lt;FinishLine&gt;().finishMenu;&#10;            }&#10;            &#10;            &#10;            finishMenu.gameObject.SetActive(true);&#10;            &#10;            string firstPlaceShip = RaceMovementPositions[0].shipName;&#10;            string secondPlaceShip = RaceMovementPositions[1].shipName;&#10;            string thirdPlaceShip = RaceMovementPositions[2].shipName;&#10;            string forthPlaceShip = RaceMovementPositions.Count &gt; 3 ? RaceMovementPositions[3].shipName : &quot;N/A&quot;;&#10;            finishMenu.UpdatePositions( firstPlaceShip, secondPlaceShip, thirdPlaceShip, forthPlaceShip);&#10;            &#10;            Transform cameraStartPosition = GameManager.Instance.GetCameraStartPosition();&#10;            &#10;            mainCamera.transform.position = cameraStartPosition.position;&#10;            mainCamera.transform.rotation = cameraStartPosition.rotation;&#10;&#10;            // Record race results in League system&#10;            RecordRaceResults();&#10;&#10;            if (isRaceDay)&#10;            {&#10;                PlayerManager.Instance.ModifyPlayerEnergy(-50);&#10;            }&#10;            else&#10;            {&#10;                PlayerManager.Instance.ModifyPlayerEnergy(-25);&#10;            }&#10;&#10;&#10;            if (RaceMovementPositions[0].isPlayerShip)&#10;            {&#10;                Debug.Log(&quot;Player finished first!&quot;);&#10;                finishMenu.UpdatePlayerMessage(true, &quot;You are the champion!&quot;);&#10;                if (isRaceDay)&#10;                {&#10;                    PlayerManager.Instance.ModifyPlayerCoins(125f); // Reward player with coins&#10;                    difficulty += .3f;&#10;                }&#10;                CheeringAndClapping = FMODUnity.RuntimeManager.CreateInstance(&quot;event:/Race/Cheering and Clapping&quot;);&#10;                CheeringAndClapping.start();&#10;                RaceAmbience.setParameterByName(&quot;Mute Positive Encouragement&quot;, 0f);&#10;                RaceAmbience.setParameterByName(&quot;Mute Rowing&quot;, 0f);&#10;&#10;&#10;            }&#10;            else&#10;            {&#10;                Debug.Log(&quot;Player did not finish first.&quot;);&#10;                finishMenu.UpdatePlayerMessage(false, &quot;Better luck next time!&quot;);&#10;                if(!isRaceDay) return; // No coins deducted&#10;                &#10;                if( PlayerManager.Instance.GetPlayerCoins () &lt; 50f)&#10;                {&#10;                    PlayerManager.Instance.ModifyPlayerCoins(0f);&#10;                }&#10;                PlayerManager.Instance.ModifyPlayerCoins(-50f); // Deduct coins for not winning&#10;&#10;                RaceAmbience.setParameterByName(&quot;Mute Rowing&quot;, 0f);&#10;                RaceAmbience.setParameterByName(&quot;Mute Positive Encouragement&quot;, 0f);&#10;                NegativeEncouragement = FMODUnity.RuntimeManager.CreateInstance(&quot;event:/Race/Negative Encouragement&quot;);&#10;                NegativeEncouragement.start();&#10;            }&#10;          &#10;            &#10;            &#10;            &#10;            &#10;            &#10;            &#10;        }&#10;    }&#10;&#10;    public void EndRace()&#10;    {&#10;        RaceMovementPositions.Clear();&#10;        foreach (GameObject ship in ships)&#10;        {&#10;            Destroy(ship);&#10;        }&#10;        ships.Clear();&#10;        isRaceStarted = false;&#10;        &#10;        mainCamera.transform.position = GameManager.Instance.cameraStartPosition.position;&#10;        mainCamera.transform.rotation = GameManager.Instance.cameraStartPosition.rotation;&#10;&#10;        RaceAmbience.stop(FMOD.Studio.STOP_MODE.ALLOWFADEOUT);&#10;    }&#10;    &#10;    IEnumerator ShowAd()&#10;    {&#10;        waitingForAd = true;&#10;        yield return new WaitForSeconds(5f);&#10;        AdsManager.Instance.interstitialAds.ShowInterstitialAd();&#10;    }&#10;    &#10;    public bool RaceFinished()&#10;    {&#10;        if(ships.Count != RaceMovementPositions.Count)&#10;        {&#10;            return false;&#10;        }&#10;      return true;&#10;    }&#10;&#10;    public void OnDisable()&#10;    {&#10;        TimeManager.Instance.todaysEvents.RemoveListener(CheckForRaceDay);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Records the race results in the League system when a player race is completed.&#10;    /// This method converts the RaceManager's ship results to the League system format.&#10;    /// &lt;/summary&gt;&#10;    private void RecordRaceResults()&#10;    {&#10;        if (LeagueController.Instance?.currentLeague == null)&#10;        {&#10;            Debug.LogWarning(&quot;No active league found - race results not recorded&quot;);&#10;            return;&#10;        }&#10;&#10;        // Get current player race from league&#10;        var currentRace = LeagueController.Instance.GetCurrentPlayerRace();&#10;        if (!currentRace.HasValue)&#10;        {&#10;            Debug.LogWarning(&quot;No current player race found in league&quot;);&#10;            return;&#10;        }&#10;&#10;        var raceDay = currentRace.Value;&#10;        &#10;        // Create arrays to store teams and their positions&#10;        Team[] raceTeams = raceDay.teams;&#10;        int[] allPositions = new int[raceTeams.Length];&#10;        &#10;        // Map ship names to team positions&#10;        // For now, we'll use a simple mapping based on ship names&#10;        // This assumes the ships were spawned in the same order as the teams in the race&#10;        for (int i = 0; i &lt; RaceMovementPositions.Count &amp;&amp; i &lt; raceTeams.Length; i++)&#10;        {&#10;            ShipMovement ship = RaceMovementPositions[i];&#10;            int position = i + 1; // Position is 1-based (1st, 2nd, 3rd, etc.)&#10;            &#10;            // Find the corresponding team for this ship&#10;            // If it's the player ship, find the player team&#10;            if (ship.isPlayerShip)&#10;            {&#10;                for (int j = 0; j &lt; raceTeams.Length; j++)&#10;                {&#10;                    if (raceTeams[j].teamType == TeamType.Player)&#10;                    {&#10;                        allPositions[j] = position;&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // For AI ships, map them to AI teams in order&#10;                // This is a simplified mapping - in a more complex system you'd want&#10;                // to properly track which ship corresponds to which team&#10;                int aiTeamIndex = 0;&#10;                for (int j = 0; j &lt; raceTeams.Length; j++)&#10;                {&#10;                    if (raceTeams[j].teamType != TeamType.Player)&#10;                    {&#10;                        if (aiTeamIndex == (i - (ship.isPlayerShip ? 0 : GetPlayerShipIndex())))&#10;                        {&#10;                            allPositions[j] = position;&#10;                            break;&#10;                        }&#10;                        aiTeamIndex++;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Find player's finishing position&#10;        int playerPosition = 0;&#10;        for (int i = 0; i &lt; RaceMovementPositions.Count; i++)&#10;        {&#10;            if (RaceMovementPositions[i].isPlayerShip)&#10;            {&#10;                playerPosition = i + 1;&#10;                break;&#10;            }&#10;        }&#10;&#10;        // Record the results in the league system&#10;        LeagueController.Instance.RecordPlayerRaceResult(playerPosition, raceTeams, allPositions);&#10;        &#10;        Debug.Log($&quot;Race results recorded - Player finished {playerPosition}&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Helper method to find the index of the player ship in the finishing order&#10;    /// &lt;/summary&gt;&#10;    private int GetPlayerShipIndex()&#10;    {&#10;        for (int i = 0; i &lt; RaceMovementPositions.Count; i++)&#10;        {&#10;            if (RaceMovementPositions[i].isPlayerShip)&#10;                return i;&#10;        }&#10;        return -1;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System.ComponentModel.Design.Serialization;&#10;using System.Linq;&#10;using System.Threading;&#10;using Calendar;&#10;using UnityEngine;&#10;using UnityEngine.Events;&#10;using UnityEngine.Rendering.Universal;&#10;using EventType = UnityEngine.EventType;&#10;using Random = UnityEngine.Random;&#10;using League;&#10;&#10;public class RaceManager : MonoBehaviour&#10;{&#10;    public static RaceManager Instance { get; private set; }&#10;    public Camera mainCamera;&#10;    public bool isRaceStarted = false;&#10;    [Header(&quot;Spawn &amp; Difficulty&quot;)]&#10;    [Range(0.5f, 100f)]&#10;    public float difficulty = 1f; &#10;    // 0.5 = easy crews, 1 = normal, 2 = monster crews&#10;    public List&lt;Transform&gt; raceStartPositions;&#10;    public UnityEvent startRace;&#10;    public bool isRaceDay;&#10;&#10;&#10;    public GameObject shipPrefab;&#10;    &#10;    &#10;    public List&lt;GameObject&gt; ships = new List&lt;GameObject&gt;();&#10;&#10;    public List&lt;ShipMovement&gt; RaceMovementPositions;&#10;    &#10;    public ShipMovement playerShip;&#10;    &#10;    [SerializeField]&#10;    private FinishMenu finishMenu;&#10;    &#10;    &#10;    [SerializeField]&#10;    public bool waitingForAd = false; // Flag to check if we are waiting for an ad to show&#10;&#10;    public FMOD.Studio.EventInstance GarageAmbience;&#10;    FMOD.Studio.EventInstance RaceAmbience;&#10;    public FMOD.Studio.EventInstance CheeringAndClapping;&#10;    FMOD.Studio.EventInstance NegativeEncouragement;&#10;&#10;    private void Awake()&#10;    {&#10;        if (Instance == null)&#10;        {&#10;            Instance = this;&#10;&#10;            GarageAmbience = FMODUnity.RuntimeManager.CreateInstance(&quot;event:/Garage/Garage Ambience&quot;);&#10;            GarageAmbience.start();&#10;        }&#10;        else&#10;        {&#10;            Destroy(gameObject);&#10;        }&#10;    }&#10;&#10;&#10;    public void OnEnable()&#10;    {&#10;        TimeManager.Instance.todaysEvents.AddListener(CheckForRaceDay);&#10;    }&#10;&#10;    &#10;    // Listener receives today's events list&#10;    public void CheckForRaceDay(List&lt;DayEventType&gt; todaysEvents)&#10;    {&#10;&#10;        if (todaysEvents != null &amp;&amp; todaysEvents.Count &gt; 0)&#10;        {&#10;            todaysEvents.ForEach(eventType =&gt;&#10;            {&#10;                if (eventType.OccasionType == Calendar.OccasionType.Race)&#10;                {&#10;                    isRaceDay = true;&#10;                }&#10;                else&#10;                {&#10;                   isRaceDay = false;&#10;                }&#10;                &#10;            });&#10;        }&#10;    }&#10;&#10;    public void SpawnShips()&#10;    {&#10;        if (!GameManager.Instance.GetGameStarted()) return;&#10;        &#10;        // Get the teams scheduled for this race from the league&#10;        var currentRace = LeagueController.Instance?.GetCurrentPlayerRace();&#10;        if (!currentRace.HasValue)&#10;        {&#10;            Debug.LogWarning(&quot;No current race found in league - using fallback ship spawning&quot;);&#10;            SpawnShipsWithFallback();&#10;            return;&#10;        }&#10;&#10;        var raceTeams = currentRace.Value.teams;&#10;        &#10;        // Ensure we don't spawn more ships than we have start positions&#10;        int shipsToSpawn = Mathf.Min(raceTeams.Length, raceStartPositions.Count);&#10;        &#10;        for (int i = 0; i &lt; shipsToSpawn; i++)&#10;        {&#10;            Transform racepos = raceStartPositions[i];&#10;            Team team = raceTeams[i];&#10;            &#10;            Debug.Log($&quot;Spawning ship for team: {team.teamName} at position: {racepos.position}&quot;);&#10;            &#10;            GameObject ship = Instantiate(shipPrefab, racepos.position, shipPrefab.transform.rotation);&#10;            var movement = ship.GetComponent&lt;ShipMovement&gt;();&#10;            &#10;            // Assign team data to ship&#10;            movement.shipName = team.teamName;&#10;            ship.name = team.teamName + &quot;_Ship&quot;;&#10;            &#10;            // Check if this is the last boat position (closest to camera) and if player team is in this race&#10;            bool isLastBoat = (i == shipsToSpawn - 1);&#10;            bool playerInRace = raceTeams.Any(t =&gt; t.teamType == TeamType.Player);&#10;            &#10;            if (isLastBoat &amp;&amp; playerInRace)&#10;            {&#10;                // Set up player ship on the last (closest to camera) position&#10;                movement.stats = PlayerManager.Instance.GetPlayerStats();&#10;                movement.isPlayerShip = true;&#10;                movement.shipName = &quot;Player Ship&quot;;&#10;                ship.name = &quot;PlayerShip&quot;;&#10;                playerShip = movement;&#10;            }&#10;            else if (team.teamType == TeamType.Player)&#10;            {&#10;                // If player team is not in last position, swap it to last position&#10;                // This ensures player is always in the last boat regardless of team order&#10;                movement.stats = team.GetTeamStats();&#10;                movement.isPlayerShip = false;&#10;                // We'll handle the player assignment after the loop&#10;            }&#10;            else&#10;            {&#10;                // Set up AI ship with team stats&#10;                movement.stats = team.GetTeamStats();&#10;                movement.isPlayerShip = false;&#10;            }&#10;            &#10;            ships.Add(ship);&#10;        }&#10;        &#10;        // Ensure player is always in the last boat (closest to camera)&#10;        if (raceTeams.Any(t =&gt; t.teamType == TeamType.Player) &amp;&amp; ships.Count &gt; 0)&#10;        {&#10;            var lastShip = ships[ships.Count - 1];&#10;            var lastMovement = lastShip.GetComponent&lt;ShipMovement&gt;();&#10;            &#10;            // Set up as player ship&#10;            lastMovement.stats = PlayerManager.Instance.GetPlayerStats();&#10;            lastMovement.isPlayerShip = true;&#10;            lastMovement.shipName = &quot;Player Ship&quot;;&#10;            lastShip.name = &quot;PlayerShip&quot;;&#10;            playerShip = lastMovement;&#10;        }&#10;        &#10;        StartCoroutine(StartShips());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Fallback method for spawning ships when no league race is available&#10;    /// &lt;/summary&gt;&#10;    private void SpawnShipsWithFallback()&#10;    {&#10;        foreach (Transform racepos in raceStartPositions)&#10;        {&#10;            Debug.Log(&quot;Spawning ship at position: &quot; + racepos.position);&#10;            GameObject ship = Instantiate(shipPrefab, racepos.position, shipPrefab.transform.rotation);&#10;            var movement = ship.GetComponent&lt;ShipMovement&gt;();&#10;            movement.shipName = &quot;Ship &quot; + (ships.Count + 1);&#10;            &#10;            // Generate AI stats as fallback&#10;            var aiStats = new CharacterStats(&#10;                strength : Random.Range(8f, 12f)  * difficulty,&#10;                stamina  : Random.Range(8f, 12f)  * difficulty,&#10;                technique: Random.Range(5f, 10f)  * difficulty,&#10;                teamWork : Random.Range(5f, 10f)  * difficulty&#10;            );&#10;            movement.stats = aiStats;&#10;            &#10;            ships.Add(ship);&#10;        }&#10;        &#10;        // Mark one as &quot;player&quot; for fallback&#10;        var playerGO = ships[ships.Count - 1];&#10;        var playerMove = playerGO.GetComponent&lt;ShipMovement&gt;();&#10;        playerMove.stats = PlayerManager.Instance.GetPlayerStats();&#10;        playerMove.isPlayerShip = true;&#10;        playerMove.shipName = &quot;Player Ship&quot;;&#10;        playerGO.name = &quot;PlayerShip&quot;;&#10;        playerShip = playerMove;&#10;        &#10;        StartCoroutine(StartShips());&#10;    }&#10;&#10;    IEnumerator StartShips()&#10;    {&#10;        yield return new WaitForSeconds(1f);&#10;        startRace.Invoke();&#10;&#10;        RaceAmbience = FMODUnity.RuntimeManager.CreateInstance(&quot;event:/Race/Race Ambience&quot;);&#10;        RaceAmbience.start();&#10;        GarageAmbience.setParameterByName(&quot;Mute Garage Ambience&quot;, 0f);&#10;        //GarageAmbience.stop(FMOD.Studio.STOP_MODE.ALLOWFADEOUT);&#10;&#10;        foreach (var go in ships)&#10;            go.GetComponent&lt;ShipMovement&gt;().SetRaceStarted(true);&#10;    }&#10;&#10;    public void ShipFinished(ShipMovement ship)&#10;    {&#10;        RaceMovementPositions.Add(ship);&#10;        &#10;        bool raceisFinished = RaceFinished();&#10;&#10;        if (ship.isPlayerShip)&#10;        {&#10;            foreach(GameObject shipGO in ships)&#10;            {&#10;                ShipMovement shipMovement = shipGO.GetComponent&lt;ShipMovement&gt;();&#10;                if(shipMovement!=null)&#10;                {&#10;                   shipMovement.SetAiStatsAfterPlayerFinished(10f); // Speed up AI ships after player finishes&#10;                }&#10;            }&#10;        }&#10;        &#10;        if (raceisFinished)&#10;        {&#10;            foreach (ShipMovement shipMovement in RaceMovementPositions)&#10;            {&#10;                Debug.Log(&quot;Ship finished: &quot; + shipMovement.shipName + &quot; at position: &quot; + (RaceMovementPositions.IndexOf(shipMovement) + 1));&#10;            }&#10;            &#10;            if(GameManager.Instance.CanShowAd())&#10;            {&#10;                StartCoroutine(ShowAd());&#10;                GameManager.Instance.HideBannerAd();&#10;            }&#10;            &#10;            &#10;        }&#10;        &#10;     &#10;    }&#10;    &#10;    public void IsRaceFinished()&#10;    {&#10;        if (RaceFinished())&#10;        {&#10;            if(finishMenu == null)&#10;            {&#10;                finishMenu = FindObjectOfType&lt;FinishLine&gt;().finishMenu;&#10;            }&#10;            &#10;            &#10;            finishMenu.gameObject.SetActive(true);&#10;            &#10;            string firstPlaceShip = RaceMovementPositions[0].shipName;&#10;            string secondPlaceShip = RaceMovementPositions[1].shipName;&#10;            string thirdPlaceShip = RaceMovementPositions[2].shipName;&#10;            string forthPlaceShip = RaceMovementPositions.Count &gt; 3 ? RaceMovementPositions[3].shipName : &quot;N/A&quot;;&#10;            finishMenu.UpdatePositions( firstPlaceShip, secondPlaceShip, thirdPlaceShip, forthPlaceShip);&#10;            &#10;            Transform cameraStartPosition = GameManager.Instance.GetCameraStartPosition();&#10;            &#10;            mainCamera.transform.position = cameraStartPosition.position;&#10;            mainCamera.transform.rotation = cameraStartPosition.rotation;&#10;&#10;            // Record race results in League system&#10;            RecordRaceResults();&#10;&#10;            if (isRaceDay)&#10;            {&#10;                PlayerManager.Instance.ModifyPlayerEnergy(-50);&#10;            }&#10;            else&#10;            {&#10;                PlayerManager.Instance.ModifyPlayerEnergy(-25);&#10;            }&#10;&#10;&#10;            if (RaceMovementPositions[0].isPlayerShip)&#10;            {&#10;                Debug.Log(&quot;Player finished first!&quot;);&#10;                finishMenu.UpdatePlayerMessage(true, &quot;You are the champion!&quot;);&#10;                if (isRaceDay)&#10;                {&#10;                    PlayerManager.Instance.ModifyPlayerCoins(125f); // Reward player with coins&#10;                    difficulty += .3f;&#10;                }&#10;                CheeringAndClapping = FMODUnity.RuntimeManager.CreateInstance(&quot;event:/Race/Cheering and Clapping&quot;);&#10;                CheeringAndClapping.start();&#10;                RaceAmbience.setParameterByName(&quot;Mute Positive Encouragement&quot;, 0f);&#10;                RaceAmbience.setParameterByName(&quot;Mute Rowing&quot;, 0f);&#10;&#10;&#10;            }&#10;            else&#10;            {&#10;                Debug.Log(&quot;Player did not finish first.&quot;);&#10;                finishMenu.UpdatePlayerMessage(false, &quot;Better luck next time!&quot;);&#10;                if(!isRaceDay) return; // No coins deducted&#10;                &#10;                if( PlayerManager.Instance.GetPlayerCoins () &lt; 50f)&#10;                {&#10;                    PlayerManager.Instance.ModifyPlayerCoins(0f);&#10;                }&#10;                PlayerManager.Instance.ModifyPlayerCoins(-50f); // Deduct coins for not winning&#10;&#10;                RaceAmbience.setParameterByName(&quot;Mute Rowing&quot;, 0f);&#10;                RaceAmbience.setParameterByName(&quot;Mute Positive Encouragement&quot;, 0f);&#10;                NegativeEncouragement = FMODUnity.RuntimeManager.CreateInstance(&quot;event:/Race/Negative Encouragement&quot;);&#10;                NegativeEncouragement.start();&#10;            }&#10;          &#10;            &#10;            &#10;            &#10;            &#10;            &#10;            &#10;        }&#10;    }&#10;&#10;    public void EndRace()&#10;    {&#10;        RaceMovementPositions.Clear();&#10;        foreach (GameObject ship in ships)&#10;        {&#10;            Destroy(ship);&#10;        }&#10;        ships.Clear();&#10;        isRaceStarted = false;&#10;        &#10;        mainCamera.transform.position = GameManager.Instance.cameraStartPosition.position;&#10;        mainCamera.transform.rotation = GameManager.Instance.cameraStartPosition.rotation;&#10;&#10;        RaceAmbience.stop(FMOD.Studio.STOP_MODE.ALLOWFADEOUT);&#10;    }&#10;    &#10;    IEnumerator ShowAd()&#10;    {&#10;        waitingForAd = true;&#10;        yield return new WaitForSeconds(5f);&#10;        AdsManager.Instance.interstitialAds.ShowInterstitialAd();&#10;    }&#10;    &#10;    public bool RaceFinished()&#10;    {&#10;        if(ships.Count != RaceMovementPositions.Count)&#10;        {&#10;            return false;&#10;        }&#10;      return true;&#10;    }&#10;&#10;    public void OnDisable()&#10;    {&#10;        TimeManager.Instance.todaysEvents.RemoveListener(CheckForRaceDay);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Records the race results in the League system when a player race is completed.&#10;    /// This method converts the RaceManager's ship results to the League system format.&#10;    /// &lt;/summary&gt;&#10;    private void RecordRaceResults()&#10;    {&#10;        if (LeagueController.Instance?.currentLeague == null)&#10;        {&#10;            Debug.LogWarning(&quot;No active league found - race results not recorded&quot;);&#10;            return;&#10;        }&#10;&#10;        // Get current player race from league&#10;        var currentRace = LeagueController.Instance.GetCurrentPlayerRace();&#10;        if (!currentRace.HasValue)&#10;        {&#10;            Debug.LogWarning(&quot;No current player race found in league&quot;);&#10;            return;&#10;        }&#10;&#10;        var raceDay = currentRace.Value;&#10;        &#10;        // Create arrays to store teams and their positions&#10;        Team[] raceTeams = raceDay.teams;&#10;        int[] allPositions = new int[raceTeams.Length];&#10;        &#10;        // Map ship names to team positions&#10;        // For now, we'll use a simple mapping based on ship names&#10;        // This assumes the ships were spawned in the same order as the teams in the race&#10;        for (int i = 0; i &lt; RaceMovementPositions.Count &amp;&amp; i &lt; raceTeams.Length; i++)&#10;        {&#10;            ShipMovement ship = RaceMovementPositions[i];&#10;            int position = i + 1; // Position is 1-based (1st, 2nd, 3rd, etc.)&#10;            &#10;            // Find the corresponding team for this ship&#10;            // If it's the player ship, find the player team&#10;            if (ship.isPlayerShip)&#10;            {&#10;                for (int j = 0; j &lt; raceTeams.Length; j++)&#10;                {&#10;                    if (raceTeams[j].teamType == TeamType.Player)&#10;                    {&#10;                        allPositions[j] = position;&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // For AI ships, map them to AI teams in order&#10;                // This is a simplified mapping - in a more complex system you'd want&#10;                // to properly track which ship corresponds to which team&#10;                int aiTeamIndex = 0;&#10;                for (int j = 0; j &lt; raceTeams.Length; j++)&#10;                {&#10;                    if (raceTeams[j].teamType != TeamType.Player)&#10;                    {&#10;                        if (aiTeamIndex == (i - (ship.isPlayerShip ? 0 : GetPlayerShipIndex())))&#10;                        {&#10;                            allPositions[j] = position;&#10;                            break;&#10;                        }&#10;                        aiTeamIndex++;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Find player's finishing position&#10;        int playerPosition = 0;&#10;        for (int i = 0; i &lt; RaceMovementPositions.Count; i++)&#10;        {&#10;            if (RaceMovementPositions[i].isPlayerShip)&#10;            {&#10;                playerPosition = i + 1;&#10;                break;&#10;            }&#10;        }&#10;&#10;        // Record the results in the league system&#10;        LeagueController.Instance.RecordPlayerRaceResult(playerPosition, raceTeams, allPositions);&#10;        &#10;        Debug.Log($&quot;Race results recorded - Player finished {playerPosition}&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Helper method to find the index of the player ship in the finishing order&#10;    /// &lt;/summary&gt;&#10;    private int GetPlayerShipIndex()&#10;    {&#10;        for (int i = 0; i &lt; RaceMovementPositions.Count; i++)&#10;        {&#10;            if (RaceMovementPositions[i].isPlayerShip)&#10;                return i;&#10;        }&#10;        return -1;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>